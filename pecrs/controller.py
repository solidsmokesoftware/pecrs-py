## Depreciated being removed


from pecrs.index import Index
from pecrs.space import Space
from pecrs.body import *
from pecrs.body import *


class Controller(Space):
   """
   :param size: Size of each collision area, in pixels. A large area means less area changes while moving but more collision checks
   :type size: int

   High-level manager of the physics system.
   """
   def __init__(self, size=256):
      super.__init__(size)
      self.shapes = {}
      
   def add(self, body, id=-1, static=True):
      """
      :param body: Body to be added to the system
      :param id: Unique identifer to assign to the body, generated by Index if None
      :param static: If the Body is Static or Dynamic
      :type body: Body
      :type id: Int
      :type static: Bool

      Adds a body to the system and space.
      """
      if id < 0:
         id = self.index.next()
      self.index.add(body, id)
      self.ids[body] = id
      area = self.grid.scale(body.shapes[0].position[0], body.shapes[0].position[1])
      self.areas[body] = area
      self.moving[body] = False
      if static == False:
         self.actives.append(body)
         self.directions[body] = (0, 0)

      for shape in body.shapes:
         self.shapes[shape] = body
         self.add_to_grid(shape, area)
      
   def delete(self, body):
      """
      :param body: Shape to removed from the space
      :type body: Shape

      Removes a body from the space.
      """
      if body in self.ids:
         self.index.delete(self.ids[body])
         del self.ids[body]
         area = self.areas[body]
         del self.areas[body]
         del self.moving[body]
         if body in self.actives:
            self.actives.remove(body)
         if body in self.directions:
            del self.directions[body]
         for shape in body.shapes:
            self.delete_from_grid(shape, area)
            del self.shapes[shape]

   def has(self, body):
      """
      :param body: Shape to check for
      :type body: Shape
      :return: True if the space contains the body, False if not
      :rtype: bool

      Checks if a space has a body in that body's area
      Note that the body's must be set correctly or errors can occur
      """
      return body in self.ids

   def has_id(self, id):
      return self.index.has_id(id)
      
   def collisions_at(self, x, y, width=1, height=1):
      """
      :param x: Posistion to search for on the x-axis
      :param y: Posistion to search for on the y-axis
      :param width: Width of the search area
      :param height: Height of the search area
      :type x: Int
      :type y: Int
      :type width: Int
      :type height: Int
      :return: List of shapes colliding at the position
      :rtype: list(Shapes)

      Gets a list of all shapes colliding at x, y
      """
      collisions = []
      for area in self.grid.scale(x, y):
         for shape in self.grid.get(area):
            if self.collider.rect_rect(width, height, x, y, shape.width, shape.height, shape.position[0], shape.position[1]):
               collisions.append(body)
      return collisions

   def collisions_with(self, body):
      """
      :param body: Shape to find collisions with
      :type body: Shape
      :return: List of shapes colliding at the position
      :rtype: list(Shape)

      Get a list of all shapes colliding with body
      """
      collisions = []
      for area in self.areas[body]:
         for shape in self.grid.get(area):
            if self.collider.rect_rect(width, height, x, y, shape.width, shape.height, shape.position[0], shape.position[1]):
               collisions.append(body)
      return collisions


      return self.collisions_at(body.shapes[0].position[0], body.shapes[0].position[1], body.shapes[0].width, body.shapes[0].height)
      
   def check_at(self, x, y, width=1, height=1):
      """
      :param x: Posistion to search for on the x-axis
      :param y: Posistion to search for on the y-axis
      :param width: Width of the search area
      :param height: Height of the search area
      :type x: Int
      :type y: Int
      :type width: Int
      :type height: Int
      :return: True if there is a collision at x, y, False if not
      :rtype: bool

      Check to see if there is a collision at x, y in space.
      """
      for area in self.get_areas(x, y, width, height):
         for body in self.grid.get(area):
            if self.collider.rect_rect(width, height, x, y, body.width, body.height, body.position[0], body.position[1]):
               return True
      return False
      
   def check(self, body):
      """
      :param body: Shape to check for collisions
      :type body: Shape
      :return: True if the body is colliding with anything in space, False if not
      :rtype: bool

      Check to see if something is colliding with body in the space.
      """
      return self.check_at(body.position[0], body.position[1], body.width, body.height)

   def check_two(self, body, other):
      """
      :param body: First Shape to check for collision
      :param other: Second Shape to check for collision
      :type body: Shape
      :type other: Shape
      :return: True if the two shapes are colliding, False if not
      :rtype: Bool

      Check to see if two shapes are colliding
      """
      return self.collider.check_rects(body, other)
