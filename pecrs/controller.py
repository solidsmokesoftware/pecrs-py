
from pecrs.index import Index
from pecrs.vector import Vector
from pecrs.space import Space
from pecrs.body import *
from pecrs.shape import *


class Controller:
   """
   :param size: Size of the collision areas
   :type size: int

   High-level manager of the physics system.
   """
   def __init__(self, size):
      self.index = Index() #: Index, Indexing system used to track bodies.
      self.factory = {} #: dict, stores uninstanced classes for production.
      self.actives = [] #: list, stores Body for processing.
      self.space = Space(size) #: Space partionining system.

      self.pointer = Rect(1, 1) #: Rect, shape for testing collisions. Unsure if this should be here or somewhere else.
      self.pos = Vector(0, 0) #: Vector, position for testing collisions. Unsure if this should be here or somewhere else.

   def make(self, kind, x, y, id=None, dx=0, dy=0):
      """
      :param kind: Class to be created
      :param x: Position in space to create the body on the horizontal plane
      :param y: Position in space to create the body on the vertical plane
      :param id: Unique identifer to assign to the body, generated by Index if None
      :param dx: Directional facing of the body
      :param dy: Directional facing of the body
      :type kind: Uninstanced AbsBody
      :type x: int
      :type y: int
      :type id: int
      :type dx: int
      :type dy: int
      :return: Newly created body
      :rtype: kind

      Produces a body of kind and adds it to the system
      Triggers on_make(body) and on_add(body) callbacks
      """
      if not id:
         id = self.index.next()
      position = Vector(x, y)
      body = kind(id, position)
      body.direction.x = dx
      body.direction.y = dy
      self.on_make(body)
      self.add(body)
      return body

   def make_key(self, key, x, y, id=None, dx=0, dy=0):
      """
      :param key: self.factory key of the body to be created
      :param x: Position in space to create the body on the horizontal plane
      :param y: Position in space to create the body on the vertical plane
      :param id: Unique identifer to assign to the body, generated by Index if None
      :param dx: Directional facing of the body
      :param dy: Directional facing of the body
      :type key: int
      :type x: int
      :type y: int
      :type id: int
      :type dx: int
      :type dy: int
      :return: Newly created body
      :rtype: AbsBody

      Produces a body from a key and adds it to the system
      Triggers on_make(body) and on_add(body) callbacks
      """
      if not id:
         id = self.index.next()
      position = Vector(x, y)
      body = self.factory[key](id, position)
      body.direction.x = dx
      body.direction.y = dy
      self.on_make(body)
      self.add(body)
      return body

   def on_make(self, body):
      """
      :param body: Body that was made by the system
      :type body: AbsBody
      
      Callback when bodies are made by the system. Override this when extending your Controller
      """
      return

   def add(self, body):
      """
      :param body: Body to be added to the system
      :type body: AbsBody

      Adds a body to the system and space.

      Triggers on_add(body) callback
      """
      self.index.add(body, body.id)
      body.area = self.space.grid.scale(body.position.x, body.position.y)
      self.space.add(body, body.area)
      
      if isinstance(body, Body): #TODO there might be a better way to do this?
         self.actives.append(body)

      self.on_add(body)

   def on_add(self, body):
      """
      :param body: Body that was added to the system
      :type body: AbsBody

      Callback when bodies are added to the system. Override this when extending your Controller
      """
      return

   def delete(self, body):
      """
      :param body: Body to be removed from the system
      :type body: AbsBody

      Removes a body from the system.
      Triggers on_delete(body) callback
      """
      self.index.delete(body.id)
      self.space.delete(body, body.area)
      if isinstance(body, Body):
         self.actives.remove(body)
      self.on_delete(body)

   def delete_id(self, id):
      """
      :param id: id of the body to be removed from the system
      :type id: int

      Removes a body from the system by id.
      Triggers on_delete(body) callback
      """
      body = self.index.list[id]
      self.delete(body)

   def on_delete(self, body):
      """
      :param body: Body removed from the system
      :type body: AbsBody

      Callback when bodies are deleted by the system. Override this when extending your Controller
      """
      return

   def update_area(self, body):
      """
      :param body: Body to have its area updated
      :type body: AbsBody

      Checks if a body has changed collision areas and if so, updates which collision area a body is in
      Don't like the way this is handled, it shouldn't be tested here I think. Probably going to change
      Triggers on_area(body, start) callback
      """

      area = self.space.grid.scale(body.position.x, body.position.y)
      if area != body.area:
         self.space.delete(body, body.area)
         self.space.add(body, area)
         body.area = area
         self.on_area(body, area)

   def on_area(self, body, start):
      """
      :param body: Body that had its area updated
      :param start: Collision area the body was moved from
      :type body: AbsBody
      :type start: Tuple(int, int)

      Callback when bodies change collision areas. Override this when extending your Controller
      """
      return

   def move(self, body, delta):
      """
      :param body: Body to be moved by the system
      :param delta: Units of time to move the body
      :type body: AbsBody
      :type delta: float

      Move a body by it's speed and direction for delta.
      Use this instead of body.move(delta) to keep track of collision area
      Triggers the on_move(body, distance) and on_motion(body) callbacks
      """
      distance = body.move(delta)
      self.update_area(body)
      self.on_move(body, distance)
      self.on_motion(body)

   def move_to(self, body, x, y, delta):
      """
      :param body: Body to be moved by the system
      :param x: Direction to move the body in on the horitzontal plane
      :param y: Direction to move the body in on the vertical plane
      :param delta: Units of time to advance the simulation by
      :type body: AbsBody
      :type x: int
      :type y: int
      :type delta: float

      Move a body by it's speed in the direction of x, y for delta.
      Use this instead of body.move(x, y, delta) to keep track of collision area
      Triggers the on_move(body, distance) and on_motion(body) callbacks
      """
      distance = body.move_to(x, y, delta)
      self.update_area(body)
      self.on_move(body, distance)
      self.on_motion(body)

   def on_move(self, body, distance):
      """
      :param body: Body that was moved by the system
      :param distance: The distance moved by the body
      :type body: AbsBody
      :type distance: tuple(int, int)

      Callback when bodies are moved by the system. Override this when extending your Controller
      """
      return

   def push(self, body, x, y):
      """
      :param body: Body to be pushed by the system
      :param x: Direction to push the body in on the horitzontal plane
      :param y: Direction to push the body in on the vertical plane
      :type body: AbsBody
      :type x: int
      :type y: int

      Pushes a body in the direction of x, y.
      Triggers callbacks for on_push(body, x, y) and on_motion(body)
      Use this instead of body.push(x, y) to keep track of collision area
      """
      body.push(x, y)
      self.on_push(body, x, y)
      self.on_motion(body)

   def on_push(self, body, x, y):
      """
      :param body: Body that was pushed in space by the system
      :param x: Direction the body was pushed in on the horitzontal plane
      :param y: Direction the body was pushed in on the vertical plane
      :type body: AbsBody
      :type x: int
      :type y: int

      Callback when bodies are pushed by the system. Override this when extending your Controller
      """
      return

   def place(self, body, x, y):
      """
      :param body: Body to be placed in space by the system
      :param x: Position to place the body in on horitzontal plane
      :param y: Position to place the body in on the vertical plane
      :type body: AbsBody
      :type x: int
      :type y: int

      Directly place a body at x, y
      Triggers the callbacks on_place(body, start) and on_motion(body)
      Use this instead of body.place(x, y) to keep track of collision area
      """
      start = body.position.x, body.position.y
      body.place(x, y)
      self.update_area(body)
      self.on_place(body, start)
      self.on_motion(body)

   def on_place(self, body, start):
      """
      :param body: Body that was placed by the system
      :param start: The location of the body before being placed
      :type body: AbsBody
      :type start: Tuple(Int, Int)

      Callback triggered when bodies are placed by the system. Override this when extending your Controller
      """
      return

   def on_motion(self, body):
      """
      :param body: Body that had its position changed by the system.
      :type body: AbsBody

      Callback when bodies change positions. This is triggered by both move and place. Override this when extending your Controller
      """
      return

   def turn(self, body, x, y):
      """
      :param body: Body to be rotated from the system
      :param x: Direction to move to in the horitzontal plane
      :param y: Direction to move to in the vertical plane
      :type body: AbsBody()
      :type x: int
      :type y: int

      Change the direction of a body
      """
      body.direction.x = x
      body.direction.y = y
      self.on_turn(body)

   def on_turn(self, body):
      """
      :param body: Body that was turned
      :type body: AbsBody()

      Callback when a body is turned by the system. Override this when extending your Controller
      """
      return

   def start(self, body):
      """
      :param body: Body to active for movement during processing by the system
      :type body: AbsBody()

      Tells a body to move when the system is processed.
      """
      body.moving = True
      self.on_start(body)

   def on_start(self, body):
      """
      :param body: Body that was actived for movement
      :type body: AbsBody()

      Callback when bodies are told to move by the system. Override this when extending your Controller
      """
      return

   def stop(self, body):
      """
      :param body: Body to deactived system movement processing for
      :type body: AbsBody()

      Tells a body to not move when the system is proccessed.
      """
      body.moving = False
      self.on_stop(body)

   def on_stop(self, body):
      """
      :param body: Body that was deactived for movement
      :type body: AbsBody()
      
      Callback when bodies are told to stop by the system. Override this when extending your Controller
      """
      return 
      
   def get(self, id):
      """
      :param id: id of the body to get
      :type id: int
      :return: AbsBody or None
      :rtype: AbsBody or None

      Gets an body by its id.
      """
      if id in self.index.list:
         return self.index.list[id]
      else:
         return None
         
   def find(self, x, y):
      """
      :param x: Position to seach for on in the horitzontal plane
      :param y: Position to seach for on in the vertical plane
      :type x: int
      :type y: int
      :return: A list of bodies located at x, y
      :rtype: List(AbsBody)

      Finds all of the bodies at x, y.
      """
      self.pos.x = x
      self.pos.y = y
      return self.space.get(self.pos, self.pointer)

   def step(self, delta):
      """
      :param delta: Units of time to advance the simulation
      :type delta: float

      Process the system for delta steps.
      Triggers the on_step_start(delta), on_step(body, delta), on_collision(body, collisions), and on_step_end(delta) callbacks
      """
      self.on_step_start(delta)
      for body in self.actives:
         self.on_step(body, delta)
         if body.moving:
            self.move(body, delta)

      #TODO This is very unoptimized
      for body in self.actives:
         collisions = self.space.get_body(body)
         if collisions:
            self.on_collision(body, collisions)
      self.on_step_end(delta)

   def on_step_start(self, delta):
      """
      :param delta: Units of time to advance the simulation
      :type delta: float

      Callback before the simulation takes a step. Override this when extending your Controller
      """
      return


   def on_step(self, body, delta):
      """
      :param body: Body being processed by the step
      :param delta: Units of time to advance the simulation
      :type body: AbsBody
      :type delta: float

      Callback when the simulation takes a step over a body. Override this when extending your Controller
      """
      return

   def on_collision(self, body, collisions):
      """
      :param body: Body involved in a collision
      :param collision: List of bodies colliding with body
      :type body: AbsBody
      :type other: List(AbsBody)

      Callback when bodies collide with another body. Override this when extending your Controller
      """
      return

   def on_step_end(self, delta):
      """
      :param delta: Units of time to advance the simulation
      :type delta: float

      Callback after the simulation takes a step. Override this when extending your Controller
      """
      return
      

         